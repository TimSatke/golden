package golden

import (
	"testing"

	"github.com/spf13/afero"
)

func setupEnvFs(fs afero.Fs) {
	if err := fs.RemoveAll("/"); err != nil {
		panic(err)
	}

	files := []struct {
		path string
		data []byte
	}{
		{"testdata/¢∞∂†.golden", []byte("Hello, World!")},
		{"testdata/001.golden", []byte("Hello, World!")},
		{"testdata/002.golden", []byte("¬ˆ¨¶§∞ƒ®¥†ç©ø•˙ªπ•¶§∞¢§foobar£™´∑®å´ß†∂®çƒ†©√¥∫¨˙ˆ˜∆µø˚")},
		{"testdata/003.golden", []byte{0x7b, 0x22, 0x42, 0x22, 0x3a, 0x5b, 0x22, 0x68, 0x22, 0x2c, 0x22, 0x22, 0x2c, 0x22, 0x65, 0x6c, 0x6c, 0x6f, 0x22, 0x2c, 0x22, 0x2c, 0x22, 0x2c, 0x22, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x22, 0x5d, 0x2c, 0x22, 0x43, 0x22, 0x3a, 0x5b, 0x5b, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x7d, 0x2c, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x7d, 0x7d, 0x2c, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x7d, 0x7d, 0x5d, 0x2c, 0x5b, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x7d, 0x7d, 0x7d, 0x2c, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x7d, 0x7d, 0x2c, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x7d, 0x7d, 0x5d, 0x2c, 0x5b, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x7d, 0x2c, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x7d, 0x2c, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x7d, 0x5d, 0x5d, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x5b, 0x7b, 0x22, 0x41, 0x22, 0x3a, 0x22, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x22, 0x2c, 0x22, 0x42, 0x22, 0x3a, 0x31, 0x32, 0x2c, 0x22, 0x44, 0x22, 0x3a, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x22, 0x45, 0x22, 0x3a, 0x22, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x22, 0x2c, 0x22, 0x46, 0x22, 0x3a, 0x6e, 0x75, 0x6c, 0x6c, 0x7d, 0x5d, 0x7d, 0xa}},
	}
	for _, file := range files {
		f, err := fs.Create(file.path)
		if err != nil {
			panic(err)
		}

		n, err := f.Write(file.data)
		if err != nil {
			panic(err)
		}
		if n != len(file.data) {
			panic("unable to write full content")
		}

		_ = f.Close()
	}
}

func TestAssertNoUpdate(t *testing.T) {
	fs := afero.NewMemMapFs()
	setupEnvFs(fs)

	g := New(t)
	g.fs = fs
	g.ShouldUpdate = false

	// assert
	g.Assert("001", []byte("Hello, World!"))
	g.Assert("002", []byte("¬ˆ¨¶§∞ƒ®¥†ç©ø•˙ªπ•¶§∞¢§foobar£™´∑®å´ß†∂®çƒ†©√¥∫¨˙ˆ˜∆µø˚"))
	g.Assert("¢∞∂†", []byte("Hello, World!"))

	// assert struct
	type y struct {
		A string
		B uint16
		D bool
		E string
		F *y
	}
	type x struct {
		B []string
		C [][]*y
		D []**y
	}
	m := y{
		A: "foobar",
		B: 12,
		D: true,
		E: "snafu",
	}
	n := y{
		A: "foobar",
		B: 12,
		D: true,
		E: "snafu",
		F: &m,
	}
	o := y{
		A: "foobar",
		B: 12,
		D: true,
		E: "snafu",
		F: &n,
	}
	q := &m
	p := x{
		B: []string{"h", "", "ello", ",", "world!"},
		C: [][]*y{{&m, &n, &n}, {&o, &n, &n}, {&m, &m, &m}},
		D: []**y{&q},
	}
	g.AssertStruct("003", p)
}
