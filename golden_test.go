package golden

import (
	"testing"

	"github.com/spf13/afero"
)

func setupEnvFs(fs afero.Fs) {
	if err := fs.RemoveAll("/"); err != nil {
		panic(err)
	}

	files := []struct {
		path string
		data []byte
	}{
		{"testdata/¢∞∂†.golden", []byte("Hello, World!")},
		{"testdata/001.golden", []byte("Hello, World!")},
		{"testdata/002.golden", []byte("¬ˆ¨¶§∞ƒ®¥†ç©ø•˙ªπ•¶§∞¢§foobar£™´∑®å´ß†∂®çƒ†©√¥∫¨˙ˆ˜∆µø˚")},
		{"testdata/003.golden", []byte{0x2a, 0xff, 0x81, 0x3, 0x1, 0x1, 0x1, 0x78, 0x1, 0xff, 0x82, 0x0, 0x1, 0x4, 0x1, 0x1, 0x41, 0x1, 0xe, 0x0, 0x1, 0x1, 0x42, 0x1, 0xff, 0x84, 0x0, 0x1, 0x1, 0x43, 0x1, 0xff, 0x8a, 0x0, 0x1, 0x1, 0x44, 0x1, 0xff, 0x8c, 0x0, 0x0, 0x0, 0x16, 0xff, 0x83, 0x2, 0x1, 0x1, 0x8, 0x5b, 0x5d, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x1, 0xff, 0x84, 0x0, 0x1, 0xc, 0x0, 0x0, 0x1c, 0xff, 0x89, 0x2, 0x1, 0x1, 0xd, 0x5b, 0x5d, 0x5b, 0x5d, 0x2a, 0x67, 0x6f, 0x6c, 0x64, 0x65, 0x6e, 0x2e, 0x79, 0x1, 0xff, 0x8a, 0x0, 0x1, 0xff, 0x88, 0x0, 0x0, 0xd, 0xff, 0x87, 0x2, 0x1, 0x2, 0xff, 0x88, 0x0, 0x1, 0xff, 0x86, 0x0, 0x0, 0x31, 0xff, 0x85, 0x3, 0x1, 0x2, 0xff, 0x86, 0x0, 0x1, 0x6, 0x1, 0x1, 0x41, 0x1, 0xc, 0x0, 0x1, 0x1, 0x42, 0x1, 0x6, 0x0, 0x1, 0x1, 0x43, 0x1, 0xe, 0x0, 0x1, 0x1, 0x44, 0x1, 0x2, 0x0, 0x1, 0x1, 0x45, 0x1, 0xc, 0x0, 0x1, 0x1, 0x46, 0x1, 0xff, 0x86, 0x0, 0x0, 0x0, 0x1b, 0xff, 0x8b, 0x2, 0x1, 0x1, 0xc, 0x5b, 0x5d, 0x2a, 0x2a, 0x67, 0x6f, 0x6c, 0x64, 0x65, 0x6e, 0x2e, 0x79, 0x1, 0xff, 0x8c, 0x0, 0x1, 0xff, 0x86, 0x0, 0x0, 0xfe, 0x1, 0xda, 0xff, 0x82, 0x1, 0xfe, 0x26, 0x40, 0xfe, 0x22, 0x40, 0x1, 0x5, 0x1, 0x68, 0x0, 0x4, 0x65, 0x6c, 0x6c, 0x6f, 0x1, 0x2c, 0x6, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21, 0x1, 0x3, 0x3, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x0, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x1, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x0, 0x0, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x1, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x0, 0x0, 0x3, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x1, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x1, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x0, 0x0, 0x0, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x1, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x0, 0x0, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x1, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x0, 0x0, 0x3, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x0, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x0, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x0, 0x1, 0x1, 0x1, 0x6, 0x66, 0x6f, 0x6f, 0x62, 0x61, 0x72, 0x1, 0xc, 0x1, 0xfd, 0x80, 0x45, 0x40, 0xff, 0xc0, 0x1, 0x1, 0x1, 0x5, 0x73, 0x6e, 0x61, 0x66, 0x75, 0x0, 0x0}},
	}
	for _, file := range files {
		f, err := fs.Create(file.path)
		if err != nil {
			panic(err)
		}

		n, err := f.Write(file.data)
		if err != nil {
			panic(err)
		}
		if n != len(file.data) {
			panic("unable to write full content")
		}

		f.Close()
	}
}

func TestAssertNoUpdate(t *testing.T) {
	fs := afero.NewMemMapFs()
	setupEnvFs(fs)

	g := New(t)
	g.fs = fs
	g.ShouldUpdate = false

	// assert
	g.Assert("001", []byte("Hello, World!"))
	g.Assert("002", []byte("¬ˆ¨¶§∞ƒ®¥†ç©ø•˙ªπ•¶§∞¢§foobar£™´∑®å´ß†∂®çƒ†©√¥∫¨˙ˆ˜∆µø˚"))
	g.Assert("¢∞∂†", []byte("Hello, World!"))

	// assert struct
	type y struct {
		A string
		B uint16
		C complex128
		D bool
		E string
		F *y
	}
	type x struct {
		A complex64
		B []string
		C [][]*y
		D []**y
	}
	m := y{
		A: "foobar",
		B: 12,
		C: 43 - 2i,
		D: true,
		E: "snafu",
	}
	n := y{
		A: "foobar",
		B: 12,
		C: 43 - 2i,
		D: true,
		E: "snafu",
		F: &m,
	}
	o := y{
		A: "foobar",
		B: 12,
		C: 43 - 2i,
		D: true,
		E: "snafu",
		F: &n,
	}
	q := &m
	p := x{
		A: 11 + 9i,
		B: []string{"h", "", "ello", ",", "world!"},
		C: [][]*y{{&m, &n, &n}, {&o, &n, &n}, {&m, &m, &m}},
		D: []**y{&q},
	}
	g.AssertStruct("003", p)
}
